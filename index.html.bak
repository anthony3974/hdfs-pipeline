<!DOCTYPE html>
<html>

<head>
  <title>Multi-VM Performance Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
      gap: 25px;
      max-width: 1800px;
      margin: 0 auto;
    }

    .chart-card {
      background: #1a1a1a;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      border: 1px solid #333;
    }

    .chart-title {
      margin: 0 0 15px 0;
      font-size: 1.2em;
      color: #4fc3f7;
      text-align: center;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
    }

    .chart-container {
      position: relative;
      height: 250px;
      width: 100%;
    }

    .updated {
      text-align: center;
      margin-top: 25px;
      opacity: 0.7;
      font-size: 0.85em;
      color: #aaa;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 25px;
      flex-wrap: wrap;
    }

    .stat-toggle {
      background: #2a2a2a;
      border: 1px solid #444;
      color: #eee;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .stat-toggle:hover {
      background: #3a3a3a;
    }

    .stat-toggle.active {
      background: #1565c0;
      border-color: #1976d2;
    }

    /* Responsive adjustments */
    @media (max-width: 1200px) {
      .dashboard {
        grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
      }
    }

    @media (max-width: 768px) {
      .dashboard {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .chart-container {
        height: 220px;
      }
    }
  </style>
</head>

<body>
  <h1>VM Performance Dashboard</h1>
  
  <div class="controls" id="statControls">
    <!-- Stat type buttons will be added dynamically -->
  </div>
  
  <div class="dashboard" id="dashboard"></div>
  <div class="updated" id="updatedText"></div>

  <script>
    class VMDashboard {
      constructor() {
        this.vmData = {};
        this.timeLabels = [];
        this.charts = {};
        this.currentStatType = 'cpu_load'; // Default to CPU
        this.statConfigs = {
          cpu_load: {
            label: 'CPU Load %',
            unit: '%',
            min: 0,
            max: 100,
            colors: ['#4fc3f7', '#29b6f6', '#0288d1', '#0277bd']
          },
          ram_percent: {
            label: 'RAM Usage %',
            unit: '%',
            min: 0,
            max: 100,
            colors: ['#81c784', '#66bb6a', '#4caf50', '#388e3c']
          },
          network: {
            label: 'Network I/O',
            unit: 'MB/s',
            min: 0,
            colors: {
              netin: '#ff9800',
              netout: '#ff5722'
            }
          }
        };
      }

      async loadData() {
        try {
          // 1. Get file list
          const res = await fetch("/data/hourly/");
          const text = await res.text();
          const files = [...text.matchAll(/href="([^"]+\.json)"/g)].map(m => m[1]);
          
          // Filter to only VM-hourly files
          const vmFiles = files
            .filter(f => f.match(/^.+-\d{4}-\d{2}-\d{2}-\d{2}\.json$/))
            .sort();
          
          // 2. Extract time labels (unique hours)
          this.timeLabels = [...new Set(
            vmFiles.map(f => f.match(/-(\d{4}-\d{2}-\d{2}-\d{2})\.json$/)[1])
          )].sort();
          
          // 3. Fetch ALL JSON files in parallel
          const results = await Promise.all(
            vmFiles.map(file =>
              fetch("/data/hourly/" + file)
                .then(r => r.json())
                .then(data => ({ file, data }))
            )
          );
          
          // 4. Initialize data structure
          this.vmData = {};
          
          // First pass: initialize all VM arrays
          for (const { file } of results) {
            // Extract VM name (handle multi-hyphen names)
            const parts = file.split('-');
            const vmName = parts.slice(0, -4).join('-');
            
            if (!this.vmData[vmName]) {
              this.vmData[vmName] = {
                cpu_load: new Array(this.timeLabels.length).fill(null),
                ram_percent: new Array(this.timeLabels.length).fill(null),
                netin: new Array(this.timeLabels.length).fill(null),
                netout: new Array(this.timeLabels.length).fill(null)
              };
            }
          }
          
          // 5. Process all results
          for (const { file, data } of results) {
            if (!data.length) continue;
            
            // Extract VM name and hour from filename
            const parts = file.split('-');
            const vmName = parts.slice(0, -4).join('-');
            const hourLabel = parts.slice(-4).join('-').replace('.json', '');
            
            const hourIndex = this.timeLabels.indexOf(hourLabel);
            
            // Calculate averages for this hour
            const cpuAvg = data.reduce((sum, entry) => sum + entry.cpu_load, 0) / data.length;
            const ramAvg = data.reduce((sum, entry) => sum + entry.ram, 0) / data.length;
            const netinAvg = data.reduce((sum, entry) => sum + entry.netin, 0) / data.length;
            const netoutAvg = data.reduce((sum, entry) => sum + entry.netout, 0) / data.length;
            
            // Convert network bytes to MB/s (assuming 5-minute intervals, 12 per hour)
            const netinMBps = (netinAvg / 1024 / 1024) / 300; // Bytes to MB per second
            const netoutMBps = (netoutAvg / 1024 / 1024) / 300; // Bytes to MB per second
            
            // Store at correct position
            if (hourIndex !== -1) {
              this.vmData[vmName].cpu_load[hourIndex] = cpuAvg;
              this.vmData[vmName].ram_percent[hourIndex] = ramAvg;
              this.vmData[vmName].netin[hourIndex] = netinMBps;
              this.vmData[vmName].netout[hourIndex] = netoutMBps;
            }
          }
          
          this.updateDashboard();
          this.updateTime();
        } catch (error) {
          console.error('Error loading data:', error);
          document.getElementById('dashboard').innerHTML = 
            '<div style="color: #f44336; text-align: center; padding: 40px;">Error loading data. Please check the server connection.</div>';
        }
      }

      createStatControls() {
        const container = document.getElementById('statControls');
        container.innerHTML = '';
        
        Object.keys(this.statConfigs).forEach(statKey => {
          const config = this.statConfigs[statKey];
          const button = document.createElement('button');
          button.className = `stat-toggle ${statKey === this.currentStatType ? 'active' : ''}`;
          button.textContent = config.label;
          button.onclick = (e) => this.switchStatType(statKey, e);
          container.appendChild(button);
        });
      }

      switchStatType(statType, event) {
        if (this.statConfigs[statType]) {
          this.currentStatType = statType;
          
          // Update active button
          document.querySelectorAll('.stat-toggle').forEach(btn => {
            btn.classList.remove('active');
          });
          
          if (event && event.target) {
            event.target.classList.add('active');
          }
          
          // Update all charts
          this.updateAllCharts();
        }
      }

      createChartCard(vmName) {
        const card = document.createElement('div');
        card.className = 'chart-card';
        card.id = `card-${vmName}`;
        
        card.innerHTML = `
          <h3 class="chart-title">${vmName}</h3>
          <div class="chart-container">
            <canvas id="chart-${vmName}"></canvas>
          </div>
        `;
        
        return card;
      }

      createChart(vmName) {
        const canvas = document.getElementById(`chart-${vmName}`);
        const config = this.statConfigs[this.currentStatType];
        const vmIndex = Object.keys(this.vmData).indexOf(vmName);
        
        if (this.currentStatType === 'network') {
          return this.createNetworkChart(canvas, vmName, config, vmIndex);
        } else {
          return this.createSingleMetricChart(canvas, vmName, config, vmIndex);
        }
      }

      createSingleMetricChart(canvas, vmName, config, vmIndex) {
        const colorIndex = vmIndex % config.colors.length;
        
        return new Chart(canvas, {
          type: 'line',
          data: {
            labels: this.timeLabels,
            datasets: [{
              label: config.label,
              data: this.vmData[vmName]?.[this.currentStatType] || [],
              borderColor: config.colors[colorIndex],
              backgroundColor: config.colors[colorIndex] + '20',
              borderWidth: 2,
              tension: 0.2,
              fill: true,
              pointBackgroundColor: config.colors[colorIndex],
              pointBorderColor: '#fff',
              pointBorderWidth: 1,
              pointRadius: 3,
              pointHoverRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: config.min === 0,
                min: config.min,
                max: config.max,
                grid: { color: '#333' },
                ticks: {
                  color: '#aaa',
                  callback: function(value) {
                    return value.toFixed(1) + (config.unit ? config.unit : '');
                  }
                },
                title: {
                  display: true,
                  text: config.label,
                  color: '#aaa'
                }
              },
              x: {
                grid: { color: '#333' },
                ticks: {
                  color: '#aaa',
                  maxRotation: 45,
                  minRotation: 0
                }
              }
            },
            plugins: {
              legend: {
                display: false
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#fff',
                bodyColor: '#fff',
                borderColor: '#444',
                borderWidth: 1,
                callbacks: {
                  label: function(context) {
                    const value = context.raw !== null ? context.raw : 0;
                    return `${config.label}: ${value.toFixed(2)}${config.unit}`;
                  }
                }
              }
            },
            interaction: {
              intersect: false,
              mode: 'nearest'
            }
          }
        });
      }

      createNetworkChart(canvas, vmName, config, vmIndex) {
        return new Chart(canvas, {
          type: 'line',
          data: {
            labels: this.timeLabels,
            datasets: [
              {
                label: 'Network In',
                data: this.vmData[vmName]?.netin || [],
                borderColor: config.colors.netin,
                backgroundColor: config.colors.netin + '20',
                borderWidth: 2,
                tension: 0.2,
                fill: true,
                pointBackgroundColor: config.colors.netin,
                pointBorderColor: '#fff',
                pointBorderWidth: 1,
                pointRadius: 3,
                pointHoverRadius: 5
              },
              {
                label: 'Network Out',
                data: this.vmData[vmName]?.netout || [],
                borderColor: config.colors.netout,
                backgroundColor: config.colors.netout + '20',
                borderWidth: 2,
                tension: 0.2,
                fill: false,
                pointBackgroundColor: config.colors.netout,
                pointBorderColor: '#fff',
                pointBorderWidth: 1,
                pointRadius: 3,
                pointHoverRadius: 5
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                min: config.min,
                grid: { color: '#333' },
                ticks: {
                  color: '#aaa',
                  callback: function(value) {
                    return value.toFixed(2) + (config.unit ? config.unit : '');
                  }
                },
                title: {
                  display: true,
                  text: config.label,
                  color: '#aaa'
                }
              },
              x: {
                grid: { color: '#333' },
                ticks: {
                  color: '#aaa',
                  maxRotation: 45,
                  minRotation: 0
                }
              }
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: {
                  color: '#aaa',
                  padding: 15,
                  usePointStyle: true
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleColor: '#fff',
                bodyColor: '#fff',
                borderColor: '#444',
                borderWidth: 1,
                callbacks: {
                  label: function(context) {
                    const value = context.raw !== null ? context.raw : 0;
                    const label = context.dataset.label;
                    return `${label}: ${value.toFixed(3)}${config.unit}`;
                  }
                }
              }
            },
            interaction: {
              intersect: false,
              mode: 'nearest'
            }
          }
        });
      }

      updateDashboard() {
        const dashboard = document.getElementById('dashboard');
        dashboard.innerHTML = '';
        
        this.createStatControls();
        
        Object.keys(this.vmData).forEach(vmName => {
          const card = this.createChartCard(vmName);
          dashboard.appendChild(card);
          this.charts[vmName] = this.createChart(vmName);
        });
      }

      updateAllCharts() {
        Object.keys(this.charts).forEach(vmName => {
          this.charts[vmName].destroy();
          this.charts[vmName] = this.createChart(vmName);
        });
      }

      updateTime() {
        document.getElementById('updatedText').textContent = 
          `Last updated: ${new Date().toLocaleString()} | ${Object.keys(this.vmData).length} VMs monitored`;
      }
    }

    // Initialize and auto-refresh
    const dashboard = new VMDashboard();
    
    // Load immediately and every 60 seconds
    dashboard.loadData();
    setInterval(() => dashboard.loadData(), 60000);
    
    // Also auto-refresh every 5 minutes to handle potential memory leaks
    setInterval(() => location.reload(), 300000);
  </script>
</body>
</html>